# Streamlit Demand Forecasting Application

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from datetime import date, timedelta

# --- Streamlit UI Configuration (MUST BE FIRST) ---
st.set_page_config(page_title="Demand Forecasting App", layout="centered")

# --- 1. Load Model and Features ---
# Ensure 'xgboost_demand_model.joblib' and 'model_features.joblib' are in the same directory
try:
    model = joblib.load('xgboost_demand_model.joblib')
    features = joblib.load('model_features.joblib')
    st.sidebar.success("Model and features loaded successfully!")
except FileNotFoundError:
    st.sidebar.error("Error: Model files not found. Please run the Jupyter notebook first to train and save the model.")
    st.stop() # Stop the app if model files are missing

# Function to create features, consistent with the notebook
def create_features_for_prediction(df):
    """
    Creates time series features from the date index.
    This function must be identical to the one used during training.
    """
    df['year'] = df.index.year
    df['month'] = df.index.month
    df['day'] = df.index.day
    df['dayofweek'] = df.index.dayofweek
    df['dayofyear'] = df.index.dayofyear
    df['weekofyear'] = df.index.isocalendar().week.astype(int)
    df['quarter'] = df.index.quarter
    df['is_month_start'] = df.index.is_month_start.astype(int)
    df['is_month_end'] = df.index.is_month_end.astype(int)
    df['is_quarter_start'] = df.index.is_quarter_start.astype(int)
    df['is_quarter_end'] = df.index.is_quarter_end.astype(int)
    df['is_year_start'] = df.index.is_year_start.astype(int)
    df['is_year_end'] = df.index.is_year_end.astype(int)

    # Note: Lag and rolling features require historical data.
    # For new predictions, we'd typically need to compute these based on the most recent
    # available historical data. For simplicity in this app, we'll use placeholder
    # values for these if predicting a single future date without a full history.
    # In a real-world scenario, you'd feed the last N days of actual sales to this function.

    try:
        # Load train.csv without immediate date parsing/indexing to check raw columns
        temp_historical_df = pd.read_csv('train.csv')
        temp_historical_df.columns = temp_historical_df.columns.str.strip().str.lower()

        # Check if 'date' column exists after initial load
        #if 'date' not in temp_historical_df.columns:
        #    raise ValueError("The 'train.csv' file does not contain a 'date' column. Please check the dataset.")

        # Process the historical_df consistently with the notebook
        historical_df = temp_historical_df.copy() # Work on a copy
        #historical_df['date'] = pd.to_datetime(historical_df['date'])
        #historical_df = historical_df.set_index('date').sort_index()

        # Add a dummy 'sales' column to the input df if predicting future dates
        # This is crucial for lag/rolling features computation when actual sales are unknown.
        if 'sales' not in df.columns:
            df['sales'] = np.nan

        # Combine historical sales with the current prediction dates to compute lags/rolling features
        df_combined = pd.concat([historical_df['sales'], df['sales']])
        # Drop duplicates, keeping the last one (which would be the future date if overlapping)
        df_combined = df_combined[~df_combined.index.duplicated(keep='last')]
        #df_combined = df_combined.sort_index()

        # Compute lag features on the combined series, then select for the input df's index
        df['sales_lag_1'] = df_combined.shift(1).loc[df.index]
        df['sales_lag_7'] = df_combined.shift(7).loc[df.index]

        # Compute rolling features on the combined series, then select for the input df's index
        df['sales_rolling_mean_7'] = df_combined.rolling(window=7).mean().shift(1).loc[df.index]
        df['sales_rolling_std_7'] = df_combined.rolling(window=7).std().shift(1).loc[df.index]

        # Fill NaNs generated by initial lags/rolling features (e.g., at the very start of the series)
        # with the mean of historical sales to ensure no NaNs are passed to the model.
        for col in ['sales_lag_1', 'sales_lag_7', 'sales_rolling_mean_7', 'sales_rolling_std_7']:
            if df[col].isnull().any():
                df[col] = df[col].fillna(historical_df['sales'].mean())
                
    except Exception as e:  
        # Catch any exceptions during historical data loading or feature processing
        st.sidebar.error(f"Error loading train.csv or processing historical features: {e}. Lag/rolling features might be inaccurate.")
        # As a fallback, if historical data processing fails, set lag/rolling features to 0.0
        # This prevents the app from crashing due to missing columns for features.
        for feature_col in ['sales_lag_1', 'sales_lag_7', 'sales_rolling_mean_7', 'sales_rolling_std_7']:
            if feature_col not in df.columns:
                df[feature_col] = 0.0 # Default to 0.0 or another reasonable placeholder

    # Return only the features that the model was trained on
    return df[features]

# --- Streamlit UI ---
st.title("üè≠ Short-Term Demand Forecasting")
st.markdown("Use this app to predict future sales (demand) for your manufacturing plant using an XGBoost model.")

st.sidebar.header("Prediction Inputs")
prediction_type = st.sidebar.radio("Select Prediction Type:", ("Single Date", "Date Range"))

if prediction_type == "Single Date":
    predict_date = st.sidebar.date_input("Select a date for prediction:", min_value=date.today())

    if st.sidebar.button("Predict Demand"):
        if predict_date:
            st.subheader(f"Forecasting for: {predict_date.strftime('%Y-%m-%d')}")
            # Create a DataFrame for the prediction date
            future_df = pd.DataFrame({'date': [predict_date]})
            future_df['date'] = pd.to_datetime(future_df['date'])
            future_df = future_df.set_index('date')

            # Create features for the future date
            future_features = create_features_for_prediction(future_df.copy())

            # Make prediction
            try:
                prediction = model.predict(future_features)[0]
                st.metric(label="Predicted Sales (Demand)", value=f"{prediction:.2f}")
                st.success("Prediction complete!")
            except Exception as e:
                st.error(f"Error during prediction: {e}")
                st.warning("Please ensure the input date can generate all required features. Lag/rolling features might be tricky for single future dates.")
        else:
            st.warning("Please select a date to predict.")

elif prediction_type == "Date Range":
    start_date = st.sidebar.date_input("Start Date:", min_value=date.today())
    end_date = st.sidebar.date_input("End Date:", min_value=start_date + timedelta(days=1))

    if st.sidebar.button("Predict Demand for Range"):
        if start_date and end_date <= end_date:
            st.subheader(f"Forecasting for Range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")

            # Generate a date range
            date_range = pd.date_range(start=start_date, end=end_date, freq='D')
            future_df_range = pd.DataFrame({'date': date_range})
            future_df_range = future_df_range.set_index('date')

            # Create features for the date range
            future_features_range = create_features_for_prediction(future_df_range.copy())

            # Make predictions
            try:
                predictions_range = model.predict(future_features_range)
                forecast_df = pd.DataFrame({
                    'Date': date_range,
                    'Predicted Sales': predictions_range
                }).set_index('Date')

                st.write(forecast_df)

                st.line_chart(forecast_df['Predicted Sales'])

                st.success("Range prediction complete!")
            except Exception as e:
                st.error(f"Error during range prediction: {e}")
                st.warning("Ensure all required features can be generated for the entire date range.")

        else:
            st.warning("Please select a valid date range.")

st.markdown("---")
st.markdown("### How to Use:")
st.markdown("1. Run the provided Jupyter Notebook (`demand_forecast_notebook.py` content) to train the model and save `xgboost_demand_model.joblib` and `model_features.joblib`.")
st.markdown("2. Ensure `train.csv`, `xgboost_demand_model.joblib`, and `model_features.joblib` are in the same directory as this Streamlit app.")
st.markdown("3. Run this Streamlit app using `streamlit run your_app_name.py` from your terminal.")
st.markdown("4. Select a date or date range in the sidebar and click 'Predict Demand'.")
